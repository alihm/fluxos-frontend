/**
 * Pre-rendering script for SEO
 * Generates static HTML for key landing pages so search engines can index content
 *
 * Run after build: node scripts/prerender.js
 * Or use: npm run build:seo (builds + prerenders)
 *
 * Requirements:
 * - Node.js 18+
 * - Playwright with Chromium: npx playwright install chromium
 * - System dependencies: npx playwright install-deps chromium (requires sudo)
 *
 * For CI/CD (Vercel, GitHub Actions, etc.):
 * - Add `npx playwright install chromium` to your build script
 * - Most CI environments have browser deps pre-installed
 *
 * Routes are loaded from:
 * 1. prerender-routes.json (generated by fetch-prerender-routes.js from API)
 * 2. Fallback to static routes if the file doesn't exist
 */

import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import { chromium } from 'playwright'
import { createServer } from 'http'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const distPath = path.join(__dirname, '../dist')

// Fallback static routes (used if prerender-routes.json doesn't exist)
const FALLBACK_ROUTES = [
  // Main landing pages
  '/',
  '/marketplace',
  '/marketplace/wordpress',
  '/marketplace/games',
  '/flux-drive',
  '/apps/register',
  '/cost-calculator',

  // Dashboard pages (public info)
  '/dashboards/overview',
  '/dashboards/resources',
  '/dashboards/locations',
]

/**
 * Load routes from prerender-routes.json or use fallback
 */
function loadRoutes() {
  const routesFilePath = path.join(__dirname, 'prerender-routes.json')

  if (fs.existsSync(routesFilePath)) {
    try {
      const routesData = JSON.parse(fs.readFileSync(routesFilePath, 'utf-8'))
      const routes = routesData.allRoutes || FALLBACK_ROUTES

      console.log(`üìÑ Loaded ${routes.length} routes from prerender-routes.json`)
      console.log(`   Generated at: ${routesData.generatedAt || 'unknown'}`)
      if (routesData.stats) {
        console.log(`   Stats: ${routesData.stats.marketplaceApps} apps, ${routesData.stats.trendingGames} games`)
      }

      return routes
    } catch (error) {
      console.warn(`‚ö†Ô∏è Failed to parse prerender-routes.json: ${error.message}`)
      console.log('   Using fallback static routes')

      return FALLBACK_ROUTES
    }
  }

  console.log('‚ö†Ô∏è prerender-routes.json not found, using fallback static routes')
  console.log('   Run "node scripts/fetch-prerender-routes.js" to generate dynamic routes')

  return FALLBACK_ROUTES
}

// Load routes
const routes = loadRoutes()

/**
 * Create a simple static file server
 */
function createStaticServer(directory, port) {
  return new Promise((resolve, reject) => {
    const server = createServer((req, res) => {
      let filePath = path.join(directory, req.url === '/' ? 'index.html' : req.url)

      // If path doesn't have extension, try index.html
      if (!path.extname(filePath)) {
        filePath = path.join(directory, 'index.html')
      }

      fs.readFile(filePath, (err, data) => {
        if (err) {
          // Fallback to index.html for SPA routing
          fs.readFile(path.join(directory, 'index.html'), (err2, data2) => {
            if (err2) {
              res.writeHead(404)
              res.end('Not found')
              
              return
            }
            const ext = '.html'
            const contentType = getContentType(ext)
            res.writeHead(200, { 'Content-Type': contentType })
            res.end(data2)
          })
          
          return
        }

        const ext = path.extname(filePath)
        const contentType = getContentType(ext)
        res.writeHead(200, { 'Content-Type': contentType })
        res.end(data)
      })
    })

    server.listen(port, () => {
      resolve(server)
    })

    server.on('error', reject)
  })
}

function getContentType(ext) {
  const types = {
    '.html': 'text/html',
    '.js': 'application/javascript',
    '.css': 'text/css',
    '.json': 'application/json',
    '.png': 'image/png',
    '.jpg': 'image/jpeg',
    '.gif': 'image/gif',
    '.svg': 'image/svg+xml',
    '.woff': 'font/woff',
    '.woff2': 'font/woff2',
    '.ttf': 'font/ttf',
    '.webp': 'image/webp',
  }
  
  return types[ext] || 'application/octet-stream'
}

/**
 * Clean up duplicate meta tags from HTML
 * @vueuse/head adds new meta tags but doesn't remove the original static ones from index.html
 * This function keeps only the last occurrence of each meta tag (the dynamically added one)
 */
function cleanDuplicateMetaTags(html) {
  // Parse all meta tags
  const metaTagRegex = /<meta\s+([^>]+)>/gi
  const metaTags = []
  let match

  while ((match = metaTagRegex.exec(html)) !== null) {
    metaTags.push({
      fullTag: match[0],
      attributes: match[1],
      index: match.index,
    })
  }

  // Group meta tags by their identifier (name, property, or charset)
  const getMetaKey = attrs => {
    const nameMatch = attrs.match(/name=["']([^"']+)["']/i)
    const propertyMatch = attrs.match(/property=["']([^"']+)["']/i)
    const charsetMatch = attrs.match(/charset/i)
    const httpEquivMatch = attrs.match(/http-equiv=["']([^"']+)["']/i)

    if (nameMatch) return `name:${nameMatch[1]}`
    if (propertyMatch) return `property:${propertyMatch[1]}`
    if (charsetMatch) return 'charset'
    if (httpEquivMatch) return `http-equiv:${httpEquivMatch[1]}`

    return null
  }

  // Find duplicates and mark earlier ones for removal
  const seenKeys = new Map()
  const tagsToRemove = []

  // Process in reverse order to keep the last occurrence (dynamically added one)
  for (let i = metaTags.length - 1; i >= 0; i--) {
    const tag = metaTags[i]
    const key = getMetaKey(tag.attributes)

    if (key) {
      if (seenKeys.has(key)) {
        // This is a duplicate (earlier occurrence), mark for removal
        tagsToRemove.push(tag.fullTag)
      } else {
        seenKeys.set(key, tag)
      }
    }
  }

  // Remove duplicate tags (earlier occurrences)
  let cleanedHtml = html
  for (const tagToRemove of tagsToRemove) {
    // Only remove the first occurrence of each duplicate
    cleanedHtml = cleanedHtml.replace(tagToRemove + '\n', '')
    cleanedHtml = cleanedHtml.replace(tagToRemove, '')
  }

  // Also clean up duplicate canonical link tags
  const canonicalRegex = /<link\s+rel=["']canonical["']\s+href=["'][^"']+["']\s*\/?>/gi
  const canonicalTags = []
  while ((match = canonicalRegex.exec(html)) !== null) {
    canonicalTags.push(match[0])
  }

  if (canonicalTags.length > 1) {
    // Keep only the last canonical (dynamically added)
    for (let i = 0; i < canonicalTags.length - 1; i++) {
      cleanedHtml = cleanedHtml.replace(canonicalTags[i] + '\n', '')
      cleanedHtml = cleanedHtml.replace(canonicalTags[i], '')
    }
  }

  // Clean up duplicate title tags - keep the last one (dynamically set)
  const titleRegex = /<title>[^<]*<\/title>/gi
  const titleTags = []
  while ((match = titleRegex.exec(cleanedHtml)) !== null) {
    titleTags.push(match[0])
  }

  if (titleTags.length > 1) {
    // Keep only the last title (dynamically added)
    for (let i = 0; i < titleTags.length - 1; i++) {
      cleanedHtml = cleanedHtml.replace(titleTags[i] + '\n', '')
      cleanedHtml = cleanedHtml.replace(titleTags[i], '')
    }
  }

  return cleanedHtml
}

/**
 * Inject prerender indicator into HTML
 */
function injectPrerenderMeta(html) {
  const prerenderMeta = `<meta name="prerender-status" content="prerendered" data-prerender-date="${new Date().toISOString()}">`

  // Remove any existing prerender-status meta tags first (from previous runs or homepage)
  let cleanedHtml = html.replace(/<meta\s+name=["']prerender-status["'][^>]*>\s*/gi, '')

  return cleanedHtml.replace('<head>', `<head>\n    ${prerenderMeta}`)
}

async function prerender() {
  console.log('\nüöÄ Starting pre-rendering for SEO...')
  console.log(`üìÑ Routes to pre-render: ${routes.length}\n`)

  // Verify dist directory exists
  if (!fs.existsSync(distPath)) {
    console.error('‚ùå Error: dist directory not found. Run "npm run build" first.')
    process.exit(1)
  }

  const port = 3333
  let server
  let browser

  try {
    // Start static file server
    console.log('‚è≥ Starting static server...')
    server = await createStaticServer(distPath, port)
    console.log(`   Server running at http://localhost:${port}`)

    // Launch browser
    console.log('‚è≥ Launching browser...')
    browser = await chromium.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-accelerated-2d-canvas',
        '--disable-gpu',
      ],
    })

    const context = await browser.newContext({
      viewport: { width: 1920, height: 1080 },
      userAgent: 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)',
    })

    console.log('‚è≥ Rendering routes...\n')

    let successCount = 0
    let errorCount = 0

    for (const route of routes) {
      const page = await context.newPage()

      try {
        const url = `http://localhost:${port}${route}`

        // Navigate to the page
        await page.goto(url, { waitUntil: 'networkidle', timeout: 30000 })

        // Wait for app content to render
        try {
          await page.waitForFunction(() => {
            return document.querySelector('#app')?.innerHTML?.length > 100
          }, { timeout: 10000 })
        } catch {
          // If the app content check fails, wait a bit more
          await page.waitForTimeout(3000)
        }

        // Wait for @vueuse/head to update the title (non-default title means SEO loaded)
        try {
          await page.waitForFunction(() => {
            const title = document.title

            // Wait until title changes from the default
            return title && !title.includes('FluxCloud - Decentralized Web3 Cloud Infrastructure')
          }, { timeout: 5000 })
        } catch {
          // Some pages might keep default title, that's ok
        }

        // Extra wait for head meta tags to fully update
        await page.waitForTimeout(1000)

        // Get the rendered HTML
        let html = await page.content()

        // Clean up duplicate meta tags (keep dynamically added ones)
        html = cleanDuplicateMetaTags(html)

        // Inject prerender meta tag
        html = injectPrerenderMeta(html)

        // Determine output path
        let outputPath
        if (route === '/') {
          outputPath = path.join(distPath, 'index.html')
        } else {
          outputPath = path.join(distPath, route, 'index.html')
        }

        const outputDir = path.dirname(outputPath)

        // Create directory if needed
        if (!fs.existsSync(outputDir)) {
          fs.mkdirSync(outputDir, { recursive: true })
        }

        // Write the pre-rendered HTML
        fs.writeFileSync(outputPath, html)
        console.log(`  ‚úÖ ${route}`)
        successCount++
      } catch (err) {
        console.error(`  ‚ùå ${route}: ${err.message}`)
        errorCount++
      } finally {
        await page.close()
      }
    }

    console.log(`\n${'‚îÄ'.repeat(50)}`)
    console.log(`üìä Pre-rendering complete!`)
    console.log(`   ‚úÖ Success: ${successCount}`)
    if (errorCount > 0) {
      console.log(`   ‚ùå Errors: ${errorCount}`)
    }
    console.log(`${'‚îÄ'.repeat(50)}\n`)

    if (errorCount > 0 && successCount === 0) {
      process.exit(1)
    }
  } catch (error) {
    console.error('\n‚ùå Pre-rendering failed:', error.message)
    if (error.stack) {
      console.error('\nStack trace:', error.stack)
    }
    process.exit(1)
  } finally {
    if (browser) {
      await browser.close()
    }
    if (server) {
      server.close()
    }
  }
}

prerender()
