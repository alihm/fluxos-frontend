/**
 * Pre-rendering script for SEO
 * Generates static HTML for key landing pages so search engines can index content
 *
 * Run after build: node scripts/prerender.js
 * Or use: npm run build:seo (builds + prerenders)
 *
 * Requirements:
 * - Node.js 18+
 * - Playwright with Chromium: npx playwright install chromium
 * - System dependencies: npx playwright install-deps chromium (requires sudo)
 *
 * For CI/CD (Vercel, GitHub Actions, etc.):
 * - Add `npx playwright install chromium` to your build script
 * - Most CI environments have browser deps pre-installed
 *
 * Routes are loaded from:
 * 1. prerender-routes.json (generated by fetch-prerender-routes.js from API)
 * 2. Fallback to static routes if the file doesn't exist
 */

import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import { chromium } from 'playwright'
import { createServer } from 'http'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const distPath = path.join(__dirname, '../dist')

// Retry configuration
const MAX_RETRIES = 3
const INITIAL_RETRY_DELAY_MS = 1000 // 1 second
const CONCURRENCY = 4 // Number of pages to render in parallel

/**
 * Sleep for a given number of milliseconds
 */
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms))
}

// Fallback static routes (used if prerender-routes.json doesn't exist)
// Note: Homepage '/' is intentionally excluded - it has static SEO meta tags in index.html
// and prerendering it can cause issues with components like the cookie consent dialog
const FALLBACK_ROUTES = Object.freeze([
  // Main landing pages (excluding homepage)
  '/marketplace',
  '/marketplace/wordpress',
  '/marketplace/games',
  '/flux-drive',
  '/apps/register',
  '/cost-calculator',

  // Dashboard pages (public info)
  '/dashboards/overview',
  '/dashboards/resources',
  '/dashboards/locations',
])

/**
 * Load routes from prerender-routes.json or use fallback
 * Returns a new array to avoid keeping file content in memory
 */
function loadRoutes() {
  const routesFilePath = path.join(__dirname, 'prerender-routes.json')

  if (fs.existsSync(routesFilePath)) {
    try {
      const fileContent = fs.readFileSync(routesFilePath, 'utf-8')
      const routesData = JSON.parse(fileContent)
      const routes = routesData.allRoutes ? [...routesData.allRoutes] : [...FALLBACK_ROUTES]

      console.log(`üìÑ Loaded ${routes.length} routes from prerender-routes.json`)
      console.log(`   Generated at: ${routesData.generatedAt || 'unknown'}`)
      if (routesData.stats) {
        console.log(`   Stats: ${routesData.stats.marketplaceApps} apps, ${routesData.stats.trendingGames} games`)
      }

      // routesData goes out of scope here, allowing GC to collect it
      return routes
    } catch (error) {
      console.warn(`‚ö†Ô∏è Failed to parse prerender-routes.json: ${error.message}`)
      console.log('   Using fallback static routes')

      return [...FALLBACK_ROUTES]
    }
  }

  console.log('‚ö†Ô∏è prerender-routes.json not found, using fallback static routes')
  console.log('   Run "node scripts/fetch-prerender-routes.js" to generate dynamic routes')

  return [...FALLBACK_ROUTES]
}

/**
 * Read file with promise wrapper to avoid nested callbacks
 */
function readFileAsync(filePath) {
  return new Promise((resolve, reject) => {
    fs.readFile(filePath, (err, data) => {
      if (err) reject(err)
      else resolve(data)
    })
  })
}

/**
 * Create a simple static file server
 * Uses async handler to avoid nested callback closures
 */
function createStaticServer(directory, port) {
  const indexHtmlPath = path.join(directory, 'index.html')

  return new Promise((resolve, reject) => {
    const server = createServer(async (req, res) => {
      let filePath = path.join(directory, req.url === '/' ? 'index.html' : req.url)

      // If path doesn't have extension, try index.html
      if (!path.extname(filePath)) {
        filePath = indexHtmlPath
      }

      try {
        const data = await readFileAsync(filePath)
        const ext = path.extname(filePath)
        const contentType = getContentType(ext)
        res.writeHead(200, { 'Content-Type': contentType })
        res.end(data)
      } catch {
        // Fallback to index.html for SPA routing
        try {
          const data = await readFileAsync(indexHtmlPath)
          res.writeHead(200, { 'Content-Type': 'text/html' })
          res.end(data)
        } catch {
          res.writeHead(404)
          res.end('Not found')
        }
      }
    })

    server.listen(port, () => {
      resolve(server)
    })

    server.on('error', reject)
  })
}

function getContentType(ext) {
  const types = {
    '.html': 'text/html',
    '.js': 'application/javascript',
    '.css': 'text/css',
    '.json': 'application/json',
    '.png': 'image/png',
    '.jpg': 'image/jpeg',
    '.gif': 'image/gif',
    '.svg': 'image/svg+xml',
    '.woff': 'font/woff',
    '.woff2': 'font/woff2',
    '.ttf': 'font/ttf',
    '.webp': 'image/webp',
  }
  
  return types[ext] || 'application/octet-stream'
}

/**
 * Clean up duplicate meta tags from HTML
 * @vueuse/head adds new meta tags but doesn't remove the original static ones from index.html
 * This function keeps only the last occurrence of each meta tag (the dynamically added one)
 *
 * Optimized to avoid memory issues:
 * - Uses matchAll instead of exec loop to avoid regex state issues
 * - Collects all replacements first, then applies them in a single pass
 */
function cleanDuplicateMetaTags(html) {
  // Parse all meta tags using matchAll (more memory efficient than exec loop)
  const metaTagRegex = /<meta\s+([^>]+)>/gi
  const metaTags = [...html.matchAll(metaTagRegex)].map(match => ({
    fullTag: match[0],
    attributes: match[1],
    index: match.index,
  }))

  // Group meta tags by their identifier (name, property, or charset)
  const getMetaKey = attrs => {
    const nameMatch = attrs.match(/name=["']([^"']+)["']/i)
    if (nameMatch) return `name:${nameMatch[1]}`

    const propertyMatch = attrs.match(/property=["']([^"']+)["']/i)
    if (propertyMatch) return `property:${propertyMatch[1]}`

    if (/charset/i.test(attrs)) return 'charset'

    const httpEquivMatch = attrs.match(/http-equiv=["']([^"']+)["']/i)
    if (httpEquivMatch) return `http-equiv:${httpEquivMatch[1]}`

    return null
  }

  // Collect all tags to remove (using Set for deduplication)
  const tagsToRemove = new Set()

  // Find duplicate meta tags - keep last occurrence
  const seenKeys = new Map()
  for (let i = metaTags.length - 1; i >= 0; i--) {
    const tag = metaTags[i]
    const key = getMetaKey(tag.attributes)

    if (key) {
      if (seenKeys.has(key)) {
        tagsToRemove.add(tag.fullTag)
      } else {
        seenKeys.set(key, true)
      }
    }
  }

  // Find duplicate canonical link tags - keep last occurrence
  const canonicalRegex = /<link\s+rel=["']canonical["']\s+href=["'][^"']+["']\s*\/?>/gi
  const canonicalTags = [...html.matchAll(canonicalRegex)].map(m => m[0])
  if (canonicalTags.length > 1) {
    for (let i = 0; i < canonicalTags.length - 1; i++) {
      tagsToRemove.add(canonicalTags[i])
    }
  }

  // Find duplicate title tags - keep last occurrence
  const titleRegex = /<title>[^<]*<\/title>/gi
  const titleTags = [...html.matchAll(titleRegex)].map(m => m[0])
  if (titleTags.length > 1) {
    for (let i = 0; i < titleTags.length - 1; i++) {
      tagsToRemove.add(titleTags[i])
    }
  }

  // Apply all removals in a single pass using a regex that matches any tag to remove
  if (tagsToRemove.size === 0) {
    return html
  }

  // Escape special regex characters in tags and create a single removal pattern
  const escapeRegex = str => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
  const removalPattern = new RegExp(
    [...tagsToRemove].map(tag => `${escapeRegex(tag)}\\n?`).join('|'),
    'g',
  )

  return html.replace(removalPattern, '')
}

/**
 * Inject prerender indicator into HTML
 */
function injectPrerenderMeta(html) {
  const prerenderMeta = `<meta name="prerender-status" content="prerendered" data-prerender-date="${new Date().toISOString()}">`

  // Remove any existing prerender-status meta tags first (from previous runs or homepage)
  let cleanedHtml = html.replace(/<meta\s+name=["']prerender-status["'][^>]*>\s*/gi, '')

  return cleanedHtml.replace('<head>', `<head>\n    ${prerenderMeta}`)
}

/**
 * Render a single page with retry logic and exponential backoff
 * @param {Object} context - Playwright browser context
 * @param {string} route - Route to render
 * @param {number} port - Local server port
 * @returns {Promise<{success: boolean, html?: string, error?: string}>}
 */
async function renderPageWithRetry(context, route, port) {
  let lastError = null

  for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
    const page = await context.newPage()

    try {
      const url = `http://localhost:${port}${route}`

      // Navigate to the page - use domcontentloaded instead of networkidle for speed
      await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 15000 })

      // Wait for app content to render (reduced timeout)
      try {
        await page.waitForFunction(() => {
          return document.querySelector('#app')?.innerHTML?.length > 100
        }, { timeout: 5000 })
      } catch {
        // If the app content check fails, wait a bit more
        await page.waitForTimeout(1000)
      }

      // Wait for @vueuse/head to update the title (non-default title means SEO loaded)
      try {
        await page.waitForFunction(() => {
          const title = document.title

          // Wait until title changes from the default
          return title && !title.includes('FluxCloud - Decentralized Web3 Cloud Infrastructure')
        }, { timeout: 2000 })
      } catch {
        // Some pages might keep default title, that's ok
      }

      // Extra wait for head meta tags to fully update (reduced)
      await page.waitForTimeout(500)

      // Get the rendered HTML
      let html = await page.content()

      // Clean up duplicate meta tags (keep dynamically added ones)
      html = cleanDuplicateMetaTags(html)

      // Inject prerender meta tag
      html = injectPrerenderMeta(html)

      await page.close()

      return { success: true, html }
    } catch (err) {
      lastError = err
      await page.close()

      if (attempt < MAX_RETRIES) {
        const delay = INITIAL_RETRY_DELAY_MS * Math.pow(2, attempt - 1)
        console.log(`  ‚ö†Ô∏è ${route}: Attempt ${attempt} failed, retrying in ${delay}ms...`)
        await sleep(delay)
      }
    }
  }

  return { success: false, error: lastError?.message || 'Unknown error' }
}

async function prerender() {
  // Load routes inside function to avoid global memory retention
  const routes = loadRoutes()

  console.log('\nüöÄ Starting pre-rendering for SEO...')
  console.log(`üìÑ Routes to pre-render: ${routes.length}\n`)

  // Verify dist directory exists
  if (!fs.existsSync(distPath)) {
    console.error('‚ùå Error: dist directory not found. Run "npm run build" first.')
    process.exit(1)
  }

  const port = 3333
  let server
  let browser
  let context

  try {
    // Start static file server
    console.log('‚è≥ Starting static server...')
    server = await createStaticServer(distPath, port)
    console.log(`   Server running at http://localhost:${port}`)

    // Launch browser
    console.log('‚è≥ Launching browser...')
    browser = await chromium.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-accelerated-2d-canvas',
        '--disable-gpu',
      ],
    })

    // Set localStorage with cookie consent to prevent dialog from appearing during prerender.
    // Without this, the cookie consent dialog gets baked into the pre-rendered HTML as static
    // HTML without Vue event handlers, causing buttons to be unresponsive in production.
    // When Vue hydrates, there's a mismatch because the dialog is open in HTML but Vue's
    // showSettings ref is false, breaking the button click handlers.
    context = await browser.newContext({
      viewport: { width: 1920, height: 1080 },
      userAgent: 'Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)',
      storageState: {
        cookies: [],
        origins: [{
          origin: `http://localhost:${port}`,
          localStorage: [{
            name: 'flux_cookie_consent',
            value: JSON.stringify({
              version: '1.0',
              timestamp: new Date().toISOString(),
              necessary: true,
              analytics: false,
            }),
          }],
        }],
      },
    })

    console.log(`‚è≥ Rendering routes (${CONCURRENCY} concurrent)...\n`)

    let successCount = 0
    let errorCount = 0

    // Process routes in parallel batches
    const processRoute = async route => {
      const result = await renderPageWithRetry(context, route, port)

      if (result.success) {
        // Determine output path
        let outputPath
        if (route === '/') {
          outputPath = path.join(distPath, 'index.html')
        } else {
          outputPath = path.join(distPath, route, 'index.html')
        }

        const outputDir = path.dirname(outputPath)

        // Create directory if needed
        if (!fs.existsSync(outputDir)) {
          fs.mkdirSync(outputDir, { recursive: true })
        }

        // Write the pre-rendered HTML
        fs.writeFileSync(outputPath, result.html)
        console.log(`  ‚úÖ ${route}`)

        return true
      } else {
        console.error(`  ‚ùå ${route}: ${result.error} (failed after ${MAX_RETRIES} attempts)`)

        return false
      }
    }

    // Process in batches of CONCURRENCY
    for (let i = 0; i < routes.length; i += CONCURRENCY) {
      const batch = routes.slice(i, i + CONCURRENCY)
      const results = await Promise.all(batch.map(route => processRoute(route)))

      results.forEach(success => {
        if (success) successCount++
        else errorCount++
      })
    }

    console.log(`\n${'‚îÄ'.repeat(50)}`)
    console.log(`üìä Pre-rendering complete!`)
    console.log(`   ‚úÖ Success: ${successCount}`)
    if (errorCount > 0) {
      console.log(`   ‚ùå Errors: ${errorCount}`)
    }
    console.log(`${'‚îÄ'.repeat(50)}\n`)

    if (errorCount > 0 && successCount === 0) {
      process.exit(1)
    }
  } catch (error) {
    console.error('\n‚ùå Pre-rendering failed:', error.message)
    if (error.stack) {
      console.error('\nStack trace:', error.stack)
    }
    process.exit(1)
  } finally {
    // Close context explicitly before browser (proper cleanup order)
    if (context) {
      await context.close()
    }
    if (browser) {
      await browser.close()
    }
    if (server) {
      server.close()
    }
  }
}

prerender()
